package net.ages.liturgical.workbench.transformer.alwb.html;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;

import org.apache.commons.io.FilenameUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import net.ages.liturgical.workbench.transformer.utils.AlwbFileUtils;

/**
 * The purpose of this class is to load all the html files in the directory
 * specified, extract the information from them, then output them into
 * a new specified format.
 * 
 * The html files must have been generated by AGES Liturgical Workbench.
 * They must have both a left and right cell in each table row.  In other words,
 * they should be bilingual.
 * 
 * The files can be in subdirectories of the specified input directory.
 * 
 * The type of output currently supported is Latex. 
 * @author mac002
 *
 */
public class AgesAbstractLibrary {
	
	private List<AgesAbstractFile> contents = new ArrayList<AgesAbstractFile>();
//	private JsonObjectStoreManager storeManager = new JsonObjectStoreManager();

	private Map<String,String> leftMap = new TreeMap<String,String>();
	private Map<String,String> rightMap = new TreeMap<String,String>();
	
	private String dirIn = null;
	private String dirOut = null;
	private InputType typeIn = null;
	private OutputType typeOut = null;
	private InputLanguage inputLanguage = null;
	
	private String left = "leftCell";
	private String right = "rightCell";

	/**
	 * 
	 * @param dirIn the directory that contains the files to be processed.  Can have subdirectories.
	 * @param dirOut the directory into which to place the output files.
	 * @param typeIn the type of the input files
	 * @param typeOut the type of the output files
	 * @param inputLanguage for inputType ALWB, do we process the left, right, or both cells in a table row?
	 */
	public AgesAbstractLibrary(
			String dirIn
			, String dirOut
			) {
		this.dirIn = dirIn;
		this.dirOut = dirOut;
	}
	
	public void loadAlwbHtml(
			InputLanguage inputLanguage
			) {
		
		List<File> htmlFiles = AlwbFileUtils.getFilesInDirectory(dirIn, "html");
		for (File htmlFile : htmlFiles) { 
			AgesAbstractFile currentAgesFile = new AgesAbstractFile();
			currentAgesFile.setFilename(FilenameUtils.getBaseName(htmlFile.getName()));
			Document doc = Jsoup.parse(
					AlwbFileUtils.getFileAsString(htmlFile));
			Elements rows = doc.getElementsByTag("tr");
			ListIterator<Element> it = rows.listIterator();
			int rowCount = 0;
			while (it.hasNext()) {
				Element row = it.next();
				rowCount++;
				if (inputLanguage.equals(InputLanguage.BOTH) || inputLanguage.equals(InputLanguage.LEFT)) {
					List<AgesElement> leftAgesCell = processTheCellElements(
							rowCount
							, true
							, row.getElementsByClass(left).first().children()
							);
					currentAgesFile.getLeftContents().put(new Integer(rowCount), leftAgesCell);
				}
				if (inputLanguage.equals(InputLanguage.BOTH) || inputLanguage.equals(InputLanguage.RIGHT)) {
					List<AgesElement> rightAgesCell = processTheCellElements(
							rowCount
							, true
							, row.getElementsByClass(right).first().children()
							);
					currentAgesFile.getRightContents().put(new Integer(rowCount), rightAgesCell);
				}
			}
			this.getContents().add(currentAgesFile);
		}
	}
		
	private List<AgesElement> processTheCellElements(
			int row
			, boolean left
			, Elements elements
			) {
		List<AgesElement> result = new ArrayList<AgesElement>();
		Iterator<Element> it = elements.iterator();
		while (it.hasNext()) {
			Element e = it.next();
			AgesElement ages = new AgesElement();
			ages.setRowNbr(row);
			ages.setTagname(e.tagName());
			ages.setClassname(e.className());
			ages.setIsBlock(e.isBlock());
			Elements children = e.children();
			if (children.size() > 0) {
				ages.setContentIsKvp(false);
				ages.setContent(processTheCellElements(row, left, children));
			} else {
				ages.setContentIsKvp(true);
				String tdk = e.attr("data-key");
				String topic = "";
				String key = "";
				String value = e.text();
				try {
					String[] parts = tdk.split("\\|");
					if (parts.length == 2) {
						key = parts[1];
						parts = parts[0].split("_");
						if (parts.length == 4) {
							topic = parts[0];
						}
					}
				} catch (Exception exc) {
					exc.printStackTrace();
				}
				AgesKVP kvp = new AgesKVP();
				kvp.setKey(key);
				kvp.setTopic(topic);
				kvp.setValue(value);
				ages.setContent(kvp);
			}
			result.add(ages);
		}
		return result;
	}

	public void exportAsLatex(InputLanguage inputLanguage) {
		exportAsLatexTemplates();
		exportAsLatexResources(inputLanguage);
	}

	/**
	 * For each HTML file that was loaded, will create a corresponding tex file
	 * that only contains the formatting information and keys.
	 * 
	 * The template will be created from the left language (left cell of the table)
	 * if it has been loaded.  If not, it will use the right.
	 * Either way, only one side of the table row will be used, since the formatting
	 * is the same for both sides.
	 */
	private void exportAsLatexTemplates() {
		for (AgesAbstractFile file : this.getContents()) {
			System.out.println(file.getFilename());
			Map<Integer,List<AgesElement>> theRows = file.getLeftContents();
			if (file.getLeftContents().size() == 0) {
				theRows = file.getRightContents();
			}
			for (Entry<Integer,List<AgesElement>> entry : theRows.entrySet()) {
				System.out.print(entry.getKey() + ": ");
				for (AgesElement e : entry.getValue()) {
					System.out.println(e.toLatexAtem() + " ");
					System.out.println(e.toLatexAres());
				}
			}
		}

	}
	
	/**
	 * For each topic loaded, writes a corresponding tex file
	 * that contains only the keys and values.
	 * 
	 * @param inputLanguage
	 */
	private void exportAsLatexResources(InputLanguage inputLanguage) {
		
	}
	
	public List<AgesAbstractFile> getContents() {
		return contents;
	}
	public void setContents(List<AgesAbstractFile> contents) {
		this.contents = contents;
	}
	public Map<String, String> getLeftMap() {
		return leftMap;
	}
	public void setLeftMap(Map<String, String> leftMap) {
		this.leftMap = leftMap;
	}
	public Map<String, String> getRightMap() {
		return rightMap;
	}
	public void setRightMap(Map<String, String> rightMap) {
		this.rightMap = rightMap;
	}
	public String getDirIn() {
		return dirIn;
	}
	public void setDirIn(String dirIn) {
		this.dirIn = dirIn;
	}
	public String getDirOut() {
		return dirOut;
	}
	public void setDirOut(String dirOut) {
		this.dirOut = dirOut;
	}
	public OutputType getTypeOut() {
		return typeOut;
	}
	public void setTypeOut(OutputType typeOut) {
		this.typeOut = typeOut;
	}
	public InputType getTypeIn() {
		return typeIn;
	}
	public void setTypeIn(InputType typeIn) {
		this.typeIn = typeIn;
	}
	public InputLanguage getTargetCell() {
		return inputLanguage;
	}
	public void setTargetCell(InputLanguage targetCell) {
		this.inputLanguage = targetCell;
	}
}
