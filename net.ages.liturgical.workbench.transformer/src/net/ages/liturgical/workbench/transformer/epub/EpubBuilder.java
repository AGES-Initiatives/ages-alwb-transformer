package net.ages.liturgical.workbench.transformer.epub;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;
import org.jsoup.nodes.Element;

import nl.siegmann.epublib.domain.Author;
import nl.siegmann.epublib.domain.Book;
import nl.siegmann.epublib.domain.Resource;
import nl.siegmann.epublib.domain.TOCReference;
import nl.siegmann.epublib.epub.EpubWriter;

/**
 * Run this to build ePub files for the services in an entire AGES website.
 * Set the properties in the file named epub.config.
 * 
 * @author mac002
 *
 */
public class EpubBuilder {
	
	private String pathToRoot;
	private String pathToServicesIndex;
	private String ePubFileNamePrefix;
	private String pathInResources = "resources/";
	private int nGram = 5;
	private boolean generateToc = false;
	private 	boolean generateTocWithDesignations = false;
	private 	boolean generateTocWithVerses = false;
	private 	boolean generateTocWithReadings = false;
	private 	boolean generateTocWithDialogs = false;
	private 	boolean generateTocWithSources = false;
	private 	boolean generateTocWithChapVerses = false;
	private boolean generateFirstWordsIndex = false;
	private 	boolean generateFirstWordsIndexWithDesignations = false;
	private 	boolean generateFirstWordsIndexWithVerses = false;
	private 	boolean generateFirstWordsIndexWithReadings = false;
	private 	boolean generateFirstWordsIndexWithDialogs = false;
	private boolean generateFirstWordsIndexExcludeBetweenParentheses = true;
	private boolean includeMatinsOrdinary = false;
	private int indexPosition = 0;
	private String pathToMatinsOrdinary = "h/c/matinsordinary/gr-en/index.html";
	private int lettersPerRow = 5;
	
	private Map<String,String> bookIndex = new TreeMap<String,String>();
	
	private Document serviceIndexDoc = null;
	private String title = "";
	private String author;
	private String stylesPath = "";
	private String fontsPath = ""; // stylesPath + "/fonts";
	private String css = "ages.css";
	private String font1 = "Arimo-Bold.ttf";
	private String font2 = "Arimo-BoldItalic.ttf";
	private String font3 = "Arimo-Italic.ttf";
	private String font4 = "Arimo-Regular.ttf";

	private Map<String, MonthCollection> calendarMap = new TreeMap<String, MonthCollection>();
	private String classIndexMonthTr = "index-month-tr";
	private String classIndexMonth = "index-month";
	private String classIndexDayTr = "index-day-tr";
	private String classIndexDayLink = "index-day-link";
	private String classServicesIndexTable = "services-index-table";
	private String classTocDesignation = "tocDesignation";
	private String classTocVerse = "tocVerse";
	private String classTocReading = "tocReading";
	private String classTocChapVerse = "tocChapVerse";
	private String classTocSource = "tocSource";
	private String classTocDialog = "tocDialog";
	
	MonthMap monthMap = new MonthMap();
	
	boolean updateIndex = false;
	boolean separateMonthFiles = false;
	
	private SimpleDateFormat dateFormat = new SimpleDateFormat("yyy-MM-dd");
	
	private Properties props;
	
	/**
	 * 
	 * Reads the servicesindex in a website generated by AWLB. Creates an ePub
	 * containing all the HTML files referenced by the indexes. Puts the ePub in
	 * e/{ePubFileName}.epub Updates the servicesindex.html to include a link to
	 * the epub.
	 * 
	 * @param p
	 */
	public EpubBuilder(Properties p) {
		props = p;
		loadProps();
		try {
			GeneralUtils.createDir(pathToRoot+"/"+Constants.EPUB_SERVICE_DIR);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private void loadProps() {
		this.pathToServicesIndex = props.getProperty("pathToServicesIndexHtml");
		this.pathToMatinsOrdinary = props.getProperty("epub.path.to.matins.ordinary");
		this.pathToRoot = GeneralUtils.getParentPath(this.pathToServicesIndex)  + "/";
		this.title = props.getProperty("epub.title");
		this.author = props.getProperty("epub.author");
		this.ePubFileNamePrefix = props.getProperty("epub.filename.prefix");
		this.updateIndex = true;
		this.separateMonthFiles = true;
		generateToc = props.getProperty("epub.generate.toc").toLowerCase().trim().startsWith("y");
		generateTocWithDesignations = props.getProperty("epub.generate.toc.include.designations").toLowerCase().trim().startsWith("y");
		generateTocWithVerses = props.getProperty("epub.generate.toc.include.verses").toLowerCase().trim().startsWith("y");
		generateTocWithReadings = props.getProperty("epub.generate.toc.include.readings").toLowerCase().trim().startsWith("y");
		generateTocWithDialogs = props.getProperty("epub.generate.toc.include.dialogs").toLowerCase().trim().startsWith("y");
		generateTocWithSources = props.getProperty("epub.generate.toc.include.sources").toLowerCase().trim().startsWith("y");
		generateTocWithChapVerses = props.getProperty("epub.generate.toc.include.chapverses").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndex = props.getProperty("epub.generate.first.words.index").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndexWithDesignations = props.getProperty("epub.generate.first.words.index.include.designations").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndexWithVerses = props.getProperty("epub.generate.first.words.index.include.verses").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndexWithReadings = props.getProperty("epub.generate.first.words.index.include.readings").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndexWithDialogs = props.getProperty("epub.generate.first.words.index.include.dialogs").toLowerCase().trim().startsWith("y");
		generateFirstWordsIndexExcludeBetweenParentheses = props.getProperty("epub.generate.first.words.index.exclude.between.parentheses").toLowerCase().trim().startsWith("y");
		this.nGram = Integer.parseInt(props.getProperty("epub.generate.toc.number.of.words"));
		if (generateFirstWordsIndex) {
			indexPosition = Integer.parseInt(props.getProperty("epub.generate.first.words.index.position"));
			lettersPerRow = Integer.parseInt(props.getProperty("epub.index.letters.per.row"));
		} // use initialized value of zero
		includeMatinsOrdinary = props.getProperty("epub.include.matins.ordinary").toLowerCase().trim().startsWith("y");
	}
	
	/**
	 * Get today's date
	 * @return formated as yyyy-mm-dd
	 */
	private String getToday() {
		return dateFormat.format(Calendar.getInstance().getTime());
	}
	
	/**
	 * Builds the requested ePub file(s).
	 * 
	 * @return true if successful, false if not.
	 */
	public void build() {

		Pattern pYear = Pattern.compile("\\d{4}");

		String lastMonthYearUsed = "";

		TOCReference tocRefMonthYear = null;

		loadServicesIndex();

		System.out.println("Creating ePub files...");
		Book book = null;

		if (! this.separateMonthFiles) {
			book = initializeEpubBook(title,author,getToday());
		}

		List<ResourceBundle> theBundles = new ArrayList<ResourceBundle>();
		
		// Process each index file referenced in the calendarMap

		Iterator<String> monthIt = calendarMap.keySet().iterator();

		while (monthIt.hasNext()) {
			MonthCollection month = calendarMap.get(monthIt.next());
			String tocMonthYear = month.getMonth(); // use in TOC as month-year of service, e.g. September 2015
			String tocYear = "";
			String tocMonthAsNbr = "";
			try {
				Matcher m = pYear.matcher(tocMonthYear);
				if (m.find()) {
					tocYear = m.group();
					tocMonthAsNbr = monthMap.getMonthNbr(tocMonthYear.replace(tocYear, ""));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			Iterator<Entry<String, ServiceDayCollection>> sdcIt = month
					.getEntryIterator();
			while (sdcIt.hasNext()) {
				Entry<String, ServiceDayCollection> sdeIt = sdcIt.next();
				String tocServiceDay = sdeIt.getKey(); // use in TOC as day of
														// service, e.g.
														// 01-Tuesday
				ServiceDayCollection sdcValue = sdeIt.getValue();
				Iterator<Entry<String, ServiceDay>> sdIt = sdcValue
						.getEntryIterator();
				while (sdIt.hasNext()) {
					Entry<String, ServiceDay> sde = sdIt.next();
					ServiceDay sdValue = sde.getValue();
					Iterator<Entry<String, Service>> seIt = sdValue
							.getEntryIterator();
					while (seIt.hasNext()) {
						Entry<String, Service> se = seIt.next();
						Service seValue = se.getValue();
						String tocService = seValue.getTitle(); // e.g., Matins
						// Process services that are not 'custom'
						if (!tocService.toLowerCase().contains("custom")) {

							String tocLang = seValue.getLanguage(); // e.g. EN
							String seUrl = seValue.getUrl(); // relative path starting with /h

							// convert html file to format required for an ePub
							ResourceBundle bundle = transform(seUrl, tocYear,
									"<h1>" + tocService + "</h1><p class=\"lang\">(" + tocLang + ")</p>"
									+ "<p class=\"date\">" + serviceDateHeading(tocServiceDay,tocMonthYear) + "</p>"
									);							
							
							// add the converted html as a resource in the ePub
							// book
							if (!tocMonthYear.matches(lastMonthYearUsed)) {
								lastMonthYearUsed = tocMonthYear;
								if (this.separateMonthFiles) {
									book = initializeEpubBook(title + " - " + tocMonthYear,author,tocMonthYear);
									// Add Matins Ordinary if requested
									if (includeMatinsOrdinary) {
										ResourceBundle matinsOrdinary = transform(
												pathToMatinsOrdinary
												, tocYear
												, "<h1>" 
													+ "Matins Ordinary" 
													+ "</h1><p class=\"lang\">(" 
													+ tocLang 
													+ ")</p>"
												);							
										matinsOrdinary.setTitle("Matins Ordinary - " + tocLang);
										theBundles.add(matinsOrdinary);
									}
								} else {
									tocRefMonthYear = book.addSection(
											tocMonthYear,
											new Resource(
													HtmlUtils.getIndexPage(
													tocMonthYear
													, "Services start on next page."
													, css)
													.getBytes(
													    Charset.forName("UTF-8"))
													, tocMonthYear + ".html"));
								}
							}
							if (this.separateMonthFiles) {
								// add the bundle to the list of bundles
								bundle.setTitle(tocServiceDay + " - " + tocService + " " + tocLang);
								theBundles.add(bundle);
							} else {
								// add the service directly to the book
								book.addSection(tocRefMonthYear, 
										tocServiceDay + " - " + tocService + " " + tocLang, bundle.getMain());
							}
						}
					} // end while ServiceDay has entries
				} // end while ServiceDayCollection has entries
			} // end while Month has entries

			if (separateMonthFiles) {
				
				Iterator<ResourceBundle> it = theBundles.iterator();

				switch (indexPosition) {
					case 0: { // no index at all
						while (it.hasNext()) {
							ResourceBundle bundle = it.next();
							book.addSection(bundle.getTitle(), bundle.getMain());
						}
							break;
						}
					case 1: { // put index just before its service
						while (it.hasNext()) {
							ResourceBundle bundle = it.next();
							book.addSection("Index: " + bundle.getTitle(), bundle.getIndex());
							book.addSection("  Text: " + bundle.getTitle(), bundle.getMain());
						}
						break;
					}
					case 2: { // put index just after its service
						while (it.hasNext()) {
							ResourceBundle bundle = it.next();
							book.addSection("Text: " + bundle.getTitle(), bundle.getMain());
							book.addSection("  Index: " + bundle.getTitle(), bundle.getIndex());
						}
						break;
					}
					case 3: { // put all indexes at end of book
						while (it.hasNext()) {
							ResourceBundle bundle = it.next();
							book.addSection("Text: " + bundle.getTitle(), bundle.getMain());
						}
						it = theBundles.iterator();
						while (it.hasNext()) {
							ResourceBundle bundle = it.next();
							book.addSection("Index: " + bundle.getTitle(), bundle.getIndex());
						}
						break;
					}
				}
								
				String url = appendDate(ePubFileNamePrefix,"."+tocYear+"."+tocMonthAsNbr);
				writeEpubFile(
						book
						, pathToRoot + Constants.EPUB_SERVICE_DIR + "/" + tocYear + "/"
						, url);
				// reset the bundles
				theBundles = new ArrayList<ResourceBundle>();
			}
		} // end while Calendar has months

		System.out.println("ePubs are in this folder...");
		System.out.println(pathToRoot + Constants.EPUB_SERVICE_DIR);
	}
	
	private String appendDate(String filenamePrefix, String date) {
		String result = "";
		try {
			String newDate = date.toLowerCase().replaceAll(" ", "");
			
			result = filenamePrefix + newDate +".epub";
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	/**
	 * 
	 * @param file e.g. h/s/2015/10/28/li/gr-en/index.html
	 * @return 20151028ligr
	 */
	private String toServiceId(String file) {
		String result = file.substring(4,file.indexOf("/index.html")).replaceAll("/", "");
		return result;
	}

	private ResourceBundle transform(
			String file
			, String year
			, String heading) {
		ResourceBundle result = new ResourceBundle();
		StringBuffer sb = new StringBuffer();
		StringBuffer desigSb = new StringBuffer();
		String indexOfFirstLine = "";
		FirstWordsIndexer theIndex = new FirstWordsIndexer(
				this.generateFirstWordsIndexExcludeBetweenParentheses
				, this.lettersPerRow);
		try {
			File theFile = new File(pathToRoot + file);
			Document doc = getDoc(theFile);
			String lang = doc.getElementsByTag("title").first().attr("data-language").toLowerCase();
			String title = year
					+ "."
					+ doc.title()
					+ "."
					+ lang;

			// Set the name of the html file to use for the transformed HTML.
			// This is the file that will actually be zipped into the ePub.
			String newFileName = title + ".html";
			newFileName = newFileName.replaceAll(" ", "");

			// strip out the media groups. Can't be used in an ePub.
			Elements media = doc.getElementsByClass("media-group");
			for (Element element : media) {
				element.remove();
			}

			if (generateToc || generateFirstWordsIndex) {
				// Set IDs for the p.designation elements - to create an index of the sections
				String serviceId = "";
				if (newFileName.toLowerCase().contains("matinsordinary")) {
					serviceId = toServiceId(file);
				} else {
					serviceId = newFileName;
				}
				Elements rows = doc.getElementsByTag("tr");
				desigSb.append("<h3 class=\"linkSectionsTitle\">Outline of Reader and Choral Parts</h3>");
				desigSb.append("<table>");
				try {
					if (rows.size() > 0) {
						rows.get(0).attr("id",serviceId);
						desigSb.append(row("",rows.get(0).id(),"The Beginning"));
						indexOfFirstLine = anchor(
								"indexEntry"
								, newFileName + "#" + rows.get(0).id()
								,"Go directly to the start of the service...");
					} else {
						System.out.println("Got you!");
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
				String rowHtml = "";
				
				int cnt = rows.size();
				for (int i=0; i < cnt; i++) {

					Element row = rows.get(i);
					String rowId = serviceId + i;
					row.attr("id", rowId);
					String href = newFileName + "#" + rowId;
		
					if (generateTocWithDesignations || generateFirstWordsIndexWithDesignations) {
						Elements designations = row.getElementsByClass("designation");
						if (designations.size() > 0) {
							switch(designations.size()) {
							case 1: {
								rowHtml = 
										row(
												classTocDesignation
												, href
												, designations.get(0).text()
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithDesignations) {
									theIndex.add(
											designations.get(0).text()
													,href
											);
								}
								break;
							}
							case 2: {
								rowHtml =
										row(
												classTocDesignation
												, href
												, designations.get(0).text()
												, designations.get(1).text()
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithDesignations) {
									theIndex.add(
													designations.get(0).text()
															,href
									);
									theIndex.add(
													designations.get(1).text()
															,href
									);
								}
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml = 
										row(
												classTocDesignation
												, href
												, designations.get(0).text() 
													+ "  " + designations.get(1).text() 
												, designations.get(2).text() 
													+ "  " + designations.get(3).text() 
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithDesignations) {
									theIndex.add(
													designations.get(0).text()
															,href
									);
									theIndex.add(
													designations.get(1).text()
															,href
									);
									theIndex.add(
													designations.get(2).text()
															,href
									);
									theIndex.add(
													designations.get(3).text()
															,href
									);
								}
								break;
							}
						}
					}
					if (generateTocWithSources) {
						Elements sources = row.getElementsByClass("source");
						if (sources.size() > 0) {
							switch(sources.size()) {
								case 1: {
									rowHtml =
											row(
													classTocSource
													, href
													, sources.get(0).text()
											);
									desigSb.append(rowHtml);
									break;
								}
								case 2: {
									rowHtml =
											row(
													classTocSource
													, href
													, sources.get(0).text()
													, sources.get(1).text()
											);
									desigSb.append(rowHtml);
									break;
								}
							}
						}
					}
					if (generateTocWithDialogs || generateFirstWordsIndexWithDialogs) {
						Elements dialogs = row.getElementsByClass("dialog");
						if (dialogs.size() > 0) {
							switch(dialogs.size()) {
								case 1: {
									rowHtml =
											row(
													classTocDialog
													, href
													, firstNWords(dialogs.get(0).text(),nGram)
											);
									desigSb.append(rowHtml);
									if (generateFirstWordsIndexWithDialogs) {
										theIndex.add(
														firstNWords(dialogs.get(0).text( )
																,nGram)
																,href
										);
									}
									break;
								}
								case 2: {
									rowHtml =
											row(
													classTocDialog
													, href
													, firstNWords(dialogs.get(0).text(),nGram)
													, firstNWords(dialogs.get(1).text(),nGram)
											);
									desigSb.append(rowHtml);
									if (generateFirstWordsIndexWithDialogs) {
										theIndex.add(
														firstNWords(dialogs.get(0).text( )
																,nGram)
																,href
										);
										theIndex.add(
														firstNWords(dialogs.get(1).text( )
																,nGram)
																,href
										);
									}
									break;
								}
							}
						}
					}
					if (generateTocWithVerses || generateFirstWordsIndexWithVerses) {
						Elements hymns = row.getElementsByClass("hymn");
						if (hymns.size() > 0) {
							switch (hymns.size()) {
							case 1: {
								rowHtml =
										row(
												classTocVerse
												, href
												, firstNWords(hymns.get(0).text( ),nGram) 
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithVerses) {
									index(firstNWords(hymns.get(0).text( ),nGram), file);
									theIndex.add(
													firstNWords(hymns.get(0).text( )
															,nGram)
															,href
									);
								}
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocVerse
												, href
												, firstNWords(hymns.get(0).text( ),nGram) 
												, firstNWords(hymns.get(1).text(),nGram) 
										);
								desigSb.append(rowHtml);
								index(firstNWords(hymns.get(0).text( ),nGram), file);
								index(firstNWords(hymns.get(1).text( ),nGram), file);
								if (generateFirstWordsIndexWithVerses) {
									theIndex.add(
													firstNWords(hymns.get(0).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(hymns.get(1).text( )
															,nGram)
															,href
									);
								}
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml =
										row(
												classTocVerse
												, href
												, firstNWords(hymns.get(0).text( ),nGram) 
													+ "  " + firstNWords(hymns.get(1).text( ),nGram)
												, firstNWords(hymns.get(2).text(),nGram) 
													+ "  " + firstNWords(hymns.get(3).text( ),nGram)
										);
								desigSb.append(rowHtml);
								index(firstNWords(hymns.get(0).text( ),nGram), file);
								index(firstNWords(hymns.get(1).text( ),nGram), file);
								index(firstNWords(hymns.get(2).text( ),nGram), file);
								index(firstNWords(hymns.get(3).text( ),nGram), file);

								if (generateFirstWordsIndexWithVerses) {
									theIndex.add(
													firstNWords(hymns.get(0).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(hymns.get(1).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(hymns.get(2).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(hymns.get(3).text( )
															,nGram)
															,href
									);
								}
								break;
							}
						}
					}
					if (generateTocWithReadings || generateFirstWordsIndexWithReadings) {
						Elements readings = row.getElementsByClass("reading");
						if (readings.size() > 0) {
							switch (readings.size()) {
							case 1: {
								rowHtml =
										row(
												classTocReading
												, href
												, firstNWords(readings.get(0).text( ),nGram) 
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithReadings) {
									theIndex.add(
													firstNWords(readings.get(0).text( )
															,nGram)
															,href
									);
								}
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocReading
												, href
												, firstNWords(readings.get(0).text( ),nGram) 
												, firstNWords(readings.get(1).text(),nGram) 
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithReadings) {
									theIndex.add(
													firstNWords(readings.get(0).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(readings.get(1).text( )
															,nGram)
															,href
									);
								}
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml =
										row(
												classTocReading
												, href
												, firstNWords(readings.get(0).text( ),nGram) 
													+ "  " + firstNWords(readings.get(1).text( ),nGram)
												, firstNWords(readings.get(2).text(),nGram) 
													+ "  " + firstNWords(readings.get(3).text( ),nGram)
										);
								desigSb.append(rowHtml);
								if (generateFirstWordsIndexWithReadings) {
									theIndex.add(
													firstNWords(readings.get(0).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(readings.get(1).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(readings.get(2).text( )
															,nGram)
															,href
									);
									theIndex.add(
													firstNWords(readings.get(3).text( )
															,nGram)
															,href
									);
								}
								break;
							}
						}
					}
					if (generateTocWithChapVerses) {
						Elements chaps = row.getElementsByClass("chapverse");
						if (chaps.size() > 0) {
							switch (chaps.size()) {
							case 1: {
								rowHtml =
										row(
												classTocChapVerse
												, href
												, chaps.get(0).text( ) 
										);
								desigSb.append(rowHtml);
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocChapVerse
												, href
												, chaps.get(0).text( )
												, chaps.get(1).text()
										);
								desigSb.append(rowHtml);
								break;
							}
							}
						}
					}
				}
				desigSb.append("</table>");
			}
			
			
			// Grab the cleaned up content section of the doc
			Elements content = doc.getElementsByClass("content");
			
			StringBuffer bitByBit = new StringBuffer();
			boolean removeTableElements = false;
			if(removeTableElements) {
				doc.select("tr").attr("class", "textGroup");
				content = doc.getElementsByClass("textGroup");
				doc.select("tbody").tagName("div");
				doc.select("table").tagName("div");
				doc.select("tr").attr("class", "textGroup");
				doc.select("tr").tagName("div");
				doc.select("td").tagName("div");
			}


			// Set up HTML for the main contents file
			result.setMain(
					getResource(
							heading
							, null
							, null
							, content.html()
							,newFileName
					)
			);
			
			// Set up HTML for the index
			result.setIndex(
					getResource(
							heading
							, "Index"
							, indexOfFirstLine
							, theIndex.indexAsHtmlTable()
							, "index-"+newFileName
					)
			);

			// Set up HTML for the TOC
			result.setToc(
					getResource(
							heading
							, "Outline"
							, indexOfFirstLine
							, theIndex.indexAsHtmlTable()
							, "toc-"+newFileName
					)
			);

			// Create a resource for the transformed HTML
			result.setToc(
					new Resource(
							sb.toString().getBytes(Charset.forName("UTF-8"))
							, "toc-"+newFileName));

		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
	
	private Resource getResource(
			String heading
			, String subHeading
			, String indexOfFirstLine
			, String contents
			, String filename) {
		Resource result = null;
		StringBuffer sb = new StringBuffer();
		sb.append(HtmlUtils.HTMLopen);
		sb.append(HtmlUtils.getHead(title, css));
		sb.append(HtmlUtils.BODYopen);
		sb.append(heading);
		if (subHeading != null) {
			sb.append("<h3>"+subHeading+"</h3>");
		}
		if (indexOfFirstLine != null) {
			sb.append("<p class=\"entryIndex\">" + indexOfFirstLine + "</p>");
		}
		sb.append(contents);
		sb.append(HtmlUtils.BODYclose);
		sb.append(HtmlUtils.HTMLclose);
		
		result = 	new Resource(
				sb.toString().getBytes(Charset.forName("UTF-8"))
				, filename);
		
		return result;
	}
	
	private void index(String key, String value) {
		if (bookIndex.containsKey(key)) {
			bookIndex.put(key, bookIndex.get(key) + ", " + value);
		} else {
			bookIndex.put(key, value);
		}
	}
	private String anchor(String pClassName, String href, String text) {
		return
				"<p class=\""
				+ pClassName 
				+ "\">"
				+  "<a class=\"" 
				+ pClassName 
				+ "\" href=\"" 
				+ href 
				+ "\">"
				+ text 
				+ "</a>"
				+ "</p>";
	}
		
	private String tdLeft(String className, String href, String text) {
		return td("leftCell", className, href,text);
	}
	
	private String tdRight(String className, String href, String text) {
		return td("rightCell", className,href,text);
	}

	private String td(String tdClassName, String pClassName, String href, String text) {
		return
				 "<td class=\""
				+ tdClassName 
				+ "\">" 
				+ anchor(pClassName, href,text)
				+ "</td> "
				;
	}
	
	private String row(String cClassName, String href, String textLeft, String textRight) {
		return "<tr>"
				+ tdLeft(cClassName, href,textLeft)
				+ tdRight(cClassName,href,textRight)
				+ "</tr>";
	}
	
	private String row(String cClassName, String href, String text) {
		return "<tr>"
				+ tdLeft(cClassName,href,text)
				+ "</tr>";
	}
	
	private String firstNWords(String s, int nbrWords) {
		String result = "";
		StringBuffer sb = new StringBuffer();
		try {
			String [] parts = s.split(" ");
			int cnt;
			if (parts.length > nbrWords) {
				cnt = nbrWords;
				for (int i = 0; i < cnt; i++) {
					String word = parts[i];
					sb.append(word + " ");
				}
				result = sb.toString().trim();
				char last = result.charAt(result.length()-1);
				if (! Character.isLetter(last)) {
					if (last != ')') {
						result = result.substring(0, result.length()-1);
					}
				}
				result = result.replaceAll(" * ", " ");
				result = result + "...";
			} else {
				result = s;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
		
	private String serviceDateHeading(String day, String monthYear) {
		String result = day + ", " + monthYear;
		try {
			String theDayNbr = day.substring(0, 2);
			String theDayName = day.substring(3, day.length());
			result = theDayName + ", " + Integer.parseInt(theDayNbr) + " " + monthYear;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	private void writeEpubFile(Book book, String folder, String file) {
		try {
			GeneralUtils.createDir(folder);
			EpubWriter epubWriter = new EpubWriter();
			epubWriter.write(book, new FileOutputStream(folder+file));
			System.out.println(file);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Reads in the servicesindex.html file and initializes a map that records
	 * the titles of the month, service days, and the href to the index for each
	 * service day.
	 */
	private void loadServicesIndex() {
		serviceIndexDoc = getDoc(new File(pathToServicesIndex));
		Element servicesIndexTable = serviceIndexDoc.getElementsByClass(
				classServicesIndexTable).first();
		Elements rows = servicesIndexTable.getElementsByTag("tr");
		int monthCounter = 0;
		String monthKey = null;
		Iterator<Element> it = rows.iterator();
		while (it.hasNext()) {
			Element row = it.next();
			if (row.hasClass(classIndexMonthTr)) {
				String monthTitle = row.getElementsByClass(classIndexMonth)
						.first().text();
				monthCounter++;
				monthKey = padMonth(monthCounter);
				calendarMap.put(monthKey, new MonthCollection(monthTitle));
			} else if (row.hasClass(classIndexDayTr)) {
				Element link = row.getElementsByClass(classIndexDayLink)
						.first();
				String dayKey = link.text();
				String href = link.attr("href");
				MonthCollection m = calendarMap.get(monthKey);
				m.add(dayKey, pathToRoot + href);
				calendarMap.put(monthKey, m);
			}
		}
	}

	public void printCalendar() {
		Iterator<Entry<String, MonthCollection>> it = calendarMap.entrySet()
				.iterator();
		while (it.hasNext()) {
			Entry<String, MonthCollection> e = it.next();
			e.getValue().print();
		}
	}

	private String pad(int i, String prefix) {
		return prefix + String.format("%05d", i);
	}

	private String padMonth(int i) {
		return pad(i, "m");
	}

	private Document getDoc(File file) {
		Document result = null;
		try {
			result = Jsoup.parse(file, "UTF-8");
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	private Book initializeEpubBook(
			String theTitle
			, String theAuthor
			, String theDate
			) {
		
		Book book = null;
		try {
			// Create new Book
			book = new Book();

			// Set the title
			book.getMetadata().addTitle(theTitle);

			// Add an Author
			book.getMetadata().addAuthor(new Author(theAuthor));

			// Set cover image
//			book.setCoverImage(getResource(pathInResources + "cover.png",
	//				"cover.png"));

			// Set cover page
//			book.setCoverPage(getResource(pathInResources + "cover.html",
	//				"cover.html"));

			// Add the fonts
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font1),
							fontsPath + font1));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font2),
							fontsPath + font2));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font3),
							fontsPath + font3));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font4),
							fontsPath + font4));

			// Add css file
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + css),
							stylesPath + css));

			// Add preface
			book.addSection(
					"Preface",
					getResource(EpubBuilder.class
							.getResourceAsStream(pathInResources
									+ "preface.html"), "preface.html"));

		// Add sources
			book.addSection(
					"Sources",
					getResource(EpubBuilder.class
							.getResourceAsStream(pathInResources
									+ "sources.html"), "sources.html"));

		} catch (Exception e) {
			e.printStackTrace();
		}
		return book;
	}

	private static InputStream getResource(String path) {
		return EpubBuilder.class.getResourceAsStream(path);
	}

	private Resource getResource(String path, String href) {
		try {
			return new Resource(getResource(path), href);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	private static Resource getResource(InputStream is, String href) {
		try {
			return new Resource(is, href);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
