package net.ages.liturgical.workbench.transformer.epub;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;
import org.jsoup.nodes.Element;

import nl.siegmann.epublib.domain.Author;
import nl.siegmann.epublib.domain.Book;
import nl.siegmann.epublib.domain.Resource;
import nl.siegmann.epublib.domain.TOCReference;
import nl.siegmann.epublib.epub.EpubWriter;

/**
 * Run this to build ePub files for the services in an entire AGES website.
 * Set the properties in the file named epub.config.
 * 
 * @author mac002
 *
 */
public class EpubBuilder {
	
	private String pathToRoot;
	private String pathToServicesIndex;
	private String ePubFileNamePrefix;
	private String pathInResources = "resources/";
	private int nGram = 5;
	private boolean generateToc = false;
	private 	boolean generateTocWithDesignations = false;
	private 	boolean generateTocWithVerses = false;
	private 	boolean generateTocWithReadings = false;
	private 	boolean generateTocWithDialogs = false;
	private 	boolean generateTocWithSources = false;
	private 	boolean generateTocWithChapVerses = false;
	
	/**
	 * Add the following back into Transformer.config when ready to make available...
	        epub.generate.toc = yes
			# the minimal toc should probably include designations
			epub.generate.toc.include.designations = yes
			epub.generate.toc.include.verses = yes
			epub.generate.toc.include.readings = yes
			epub.generate.toc.include.dialogs = yes
			epub.generate.toc.include.sources = yes
			epub.generate.toc.include.chapverses = yes
			# the following indicates the first number of words to include from a verse, reading
			# or dialog.  It does not affect designations.
			epub.generate.toc.number.of.words = 5

	 */
	
	
	private Map<String,String> bookIndex = new TreeMap<String,String>();
	
	private Document serviceIndexDoc = null;
	private String title = "";
	private String author;
	private String stylesPath = "";
	private String fontsPath = ""; // stylesPath + "/fonts";
	private String css = "ages.css";
	private String font1 = "Arimo-Bold.ttf";
	private String font2 = "Arimo-BoldItalic.ttf";
	private String font3 = "Arimo-Italic.ttf";
	private String font4 = "Arimo-Regular.ttf";

	private Map<String, MonthCollection> calendarMap = new TreeMap<String, MonthCollection>();
	private String classIndexMonthTr = "index-month-tr";
	private String classIndexMonth = "index-month";
	private String classIndexDayTr = "index-day-tr";
	private String classIndexDayLink = "index-day-link";
	private String classServicesIndexTable = "services-index-table";
	private String classTocDesignation = "tocDesignation";
	private String classTocVerse = "tocVerse";
	private String classTocReading = "tocReading";
	private String classTocChapVerse = "tocChapVerse";
	private String classTocSource = "tocSource";
	private String classTocDialog = "tocDialog";
	
	MonthMap monthMap = new MonthMap();
	
	boolean updateIndex = false;
	boolean separateMonthFiles = false;
	
	private SimpleDateFormat dateFormat = new SimpleDateFormat("yyy-MM-dd");
	
	private Properties props;
	
	/**
	 * 
	 * Reads the servicesindex in a website generated by AWLB. Creates an ePub
	 * containing all the HTML files referenced by the indexes. Puts the ePub in
	 * e/{ePubFileName}.epub Updates the servicesindex.html to include a link to
	 * the epub.
	 * 
	 * @param p
	 */
	public EpubBuilder(Properties p) {
		props = p;
		loadProps();
		try {
			GeneralUtils.createDir(pathToRoot+"/"+Constants.EPUB_SERVICE_DIR);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private void loadProps() {
		this.pathToServicesIndex = props.getProperty("pathToServicesIndexHtml");
		this.pathToRoot = GeneralUtils.getParentPath(this.pathToServicesIndex)  + "/";
		this.title = props.getProperty("epub.title");
		this.author = props.getProperty("epub.author");
		this.ePubFileNamePrefix = props.getProperty("epub.filename.prefix");
		this.updateIndex = true;
		this.separateMonthFiles = true;
		/**
		 * 
		generateToc = props.getProperty("epub.generate.toc").toLowerCase().trim().startsWith("y");
		generateTocWithDesignations = props.getProperty("epub.generate.toc.include.designations").toLowerCase().trim().startsWith("y");
		generateTocWithVerses = props.getProperty("epub.generate.toc.include.verses").toLowerCase().trim().startsWith("y");
		generateTocWithReadings = props.getProperty("epub.generate.toc.include.readings").toLowerCase().trim().startsWith("y");
		generateTocWithDialogs = props.getProperty("epub.generate.toc.include.dialogs").toLowerCase().trim().startsWith("y");
		generateTocWithSources = props.getProperty("epub.generate.toc.include.sources").toLowerCase().trim().startsWith("y");
		generateTocWithChapVerses = props.getProperty("epub.generate.toc.include.chapverses").toLowerCase().trim().startsWith("y");
		this.nGram = Integer.parseInt(props.getProperty("epub.generate.toc.number.of.words"));
		 */
	}
	
	/**
	 * Get today's date
	 * @return formated as yyyy-mm-dd
	 */
	private String getToday() {
		return dateFormat.format(Calendar.getInstance().getTime());
	}
	
	/**
	 * Builds the requested ePub file(s).
	 * 
	 * @return true if successful, false if not.
	 */
	public void build() {

		Pattern pYear = Pattern.compile("\\d{4}");

		String lastMonthYearUsed = "";

		TOCReference tocRefMonthYear = null;

//		System.out.println("Found services for the following days...");
		loadServicesIndex();

		System.out.println("Creating ePub files...");
		Book book = null;

		if (! this.separateMonthFiles) {
			book = initializeEpubBook(title,author,getToday());
		}

		// Process each index file referenced in the calendarMap

		Iterator<String> monthIt = calendarMap.keySet().iterator();

		while (monthIt.hasNext()) {
			MonthCollection month = calendarMap.get(monthIt.next());
			String tocMonthYear = month.getMonth(); // use in TOC as month-year of service, e.g. September 2015
			String tocYear = "";
			String tocMonthAsNbr = "";
			try {
				Matcher m = pYear.matcher(tocMonthYear);
				if (m.find()) {
					tocYear = m.group();
					tocMonthAsNbr = monthMap.getMonthNbr(tocMonthYear.replace(tocYear, ""));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			Iterator<Entry<String, ServiceDayCollection>> sdcIt = month
					.getEntryIterator();
			while (sdcIt.hasNext()) {
				Entry<String, ServiceDayCollection> sdeIt = sdcIt.next();
				String tocServiceDay = sdeIt.getKey(); // use in TOC as day of
														// service, e.g.
														// 01-Tuesday
				ServiceDayCollection sdcValue = sdeIt.getValue();
				Iterator<Entry<String, ServiceDay>> sdIt = sdcValue
						.getEntryIterator();
				while (sdIt.hasNext()) {
					Entry<String, ServiceDay> sde = sdIt.next();
					ServiceDay sdValue = sde.getValue();
					Iterator<Entry<String, Service>> seIt = sdValue
							.getEntryIterator();
					while (seIt.hasNext()) {
						Entry<String, Service> se = seIt.next();
						Service seValue = se.getValue();
						String tocService = seValue.getTitle(); // e.g., Matins
						if (!tocService.toLowerCase().contains("custom")) {

							String tocLang = seValue.getLanguage(); // e.g. EN
							String seUrl = seValue.getUrl(); // path to actual
																// service
																// index.html
																// file,
																// but path
																// starts
																// with h/

							// convert html file to format required for an ePub
							Resource newHtml = transform(seUrl, tocYear,
									"<h1>" + tocService + "</h1><p class=\"lang\">(" + tocLang + ")</p>"
									+ "<p class=\"date\">" + serviceDateHeading(tocServiceDay,tocMonthYear) + "</p>"
									);									

							// add the converted html as a resource in the ePub
							// book
							if (!tocMonthYear.matches(lastMonthYearUsed)) {
								lastMonthYearUsed = tocMonthYear;
								if (this.separateMonthFiles) {
									book = initializeEpubBook(title + " - " + tocMonthYear,author,tocMonthYear);
								} else {
									tocRefMonthYear = book.addSection(
											tocMonthYear,
											new Resource(HtmlUtils.getIndexPage(
													tocMonthYear,
													"Services start on next page.",
													css).getBytes(
													Charset.forName("UTF-8")),
													tocMonthYear + ".html"));
								}
							}
							if (this.separateMonthFiles) {
								book.addSection(tocServiceDay + " - " + tocService + " " + tocLang, newHtml);
							} else {
								book.addSection(tocRefMonthYear, 
										tocServiceDay + " - " + tocService + " " + tocLang, newHtml);
							}
						}
					} // end while ServiceDay has entries
				} // end while ServiceDayCollection has entries
			} // end while Month has entries
			if (separateMonthFiles) {
				String url = appendDate(ePubFileNamePrefix,"."+tocYear+"."+tocMonthAsNbr);
				writeEpubFile(
						book
						, pathToRoot + Constants.EPUB_SERVICE_DIR + "/" + tocYear + "/"
						, url);
			}
		} // end while Calendar has months

		System.out.println("ePubs are in this folder...");
		System.out.println(pathToRoot + Constants.EPUB_SERVICE_DIR);
	}
	
	private String appendDate(String filenamePrefix, String date) {
		String result = "";
		try {
			String newDate = date.toLowerCase().replaceAll(" ", "");
			
			result = filenamePrefix + newDate +".epub";
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	/**
	 * 
	 * @param file e.g. h/s/2015/10/28/li/gr-en/index.html
	 * @return 20151028ligr
	 */
	private String toServiceId(String file) {
		String result = file.substring(4,file.indexOf("/index.html")).replaceAll("/", "");
		return result;
	}

	private Resource transform(String file, String year, String heading) {
		Resource result = null;
		StringBuffer sb = new StringBuffer();
		StringBuffer desigSb = new StringBuffer();
		List<IndexEntry> theIndex = new ArrayList<IndexEntry>();
		try {
			File theFile = new File(pathToRoot + file);
			Document doc = getDoc(theFile);
			String lang = doc.getElementsByTag("title").first().attr("data-language").toLowerCase();
			boolean bilingual = (lang.contains("-"));
			String title = year
					+ "."
					+ doc.title()
					+ "."
					+ lang;

			// Set the name of the html file to use for the transformed HTML.
			// This is the file that will actually be zipped into the ePub.
			String newFileName = title + ".html";

			// strip out the media groups. Can't be used in an ePub.
			Elements media = doc.getElementsByClass("media-group");
			for (Element element : media) {
				element.remove();
			}

			if (generateToc) {
				// Set IDs for the p.designation elements - to create an index of the sections
				String serviceId = toServiceId(file);
				Elements rows = doc.getElementsByTag("tr");
				desigSb.append("<h3 class=\"linkSectionsTitle\">Outline of Reader and Choral Parts</h3>");
				desigSb.append("<table>");
				rows.get(0).attr("id",serviceId);
				desigSb.append(row("",rows.get(0).id(),"The Beginning"));
							
				String rowHtml = "";
				
				int cnt = rows.size();
				for (int i=0; i < cnt; i++) {

					Element row = rows.get(i);
		
					if (generateTocWithDesignations) {
						Elements designations = row.getElementsByClass("designation");
						if (designations.size() > 0) {
							row.attr("id", serviceId+i);
							switch(designations.size()) {
							case 1: {
								rowHtml = 
										row(
												classTocDesignation
												, row.id()
												, designations.get(0).text()
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												designations.get(0).text()
														,row.id()
										)
								);
								break;
							}
							case 2: {
								rowHtml =
										row(
												classTocDesignation
												, row.id()
												, designations.get(0).text()
												, designations.get(1).text()
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												designations.get(0).text()
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												designations.get(1).text()
														,row.id()
										)
								);
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml = 
										row(
												classTocDesignation
												, row.id()
												, designations.get(0).text() 
													+ "  " + designations.get(1).text() 
												, designations.get(2).text() 
													+ "  " + designations.get(3).text() 
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												designations.get(0).text()
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												designations.get(1).text()
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												designations.get(2).text()
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												designations.get(3).text()
														,row.id()
										)
								);
								break;
							}
						}
					}
					if (generateTocWithSources) {
						Elements sources = row.getElementsByClass("source");
						if (sources.size() > 0) {
							row.attr("id", serviceId+i);
							switch(sources.size()) {
								case 1: {
									rowHtml =
											row(
													classTocSource
													, row.id()
													, sources.get(0).text()
											);
									desigSb.append(rowHtml);
									break;
								}
								case 2: {
									rowHtml =
											row(
													classTocSource
													, row.id()
													, sources.get(0).text()
													, sources.get(1).text()
											);
									desigSb.append(rowHtml);
									break;
								}
							}
						}
					}
					if (generateTocWithDialogs) {
						Elements dialogs = row.getElementsByClass("dialog");
						if (dialogs.size() > 0) {
							row.attr("id", serviceId+i);
							switch(dialogs.size()) {
								case 1: {
									rowHtml =
											row(
													classTocDialog
													, row.id()
													, firstNWords(dialogs.get(0).text(),nGram)
											);
									desigSb.append(rowHtml);
									theIndex.add(
											new IndexEntry(
													firstNWords(dialogs.get(0).text( )
															,nGram)
															,row.id()
											)
									);
									break;
								}
								case 2: {
									rowHtml =
											row(
													classTocDialog
													, row.id()
													, firstNWords(dialogs.get(0).text(),nGram)
													, firstNWords(dialogs.get(1).text(),nGram)
											);
									desigSb.append(rowHtml);
									theIndex.add(
											new IndexEntry(
													firstNWords(dialogs.get(0).text( )
															,nGram)
															,row.id()
											)
									);
									theIndex.add(
											new IndexEntry(
													firstNWords(dialogs.get(1).text( )
															,nGram)
															,row.id()
											)
									);
									break;
								}
							}
						}
					}
					if (generateTocWithVerses) {
						Elements hymns = row.getElementsByClass("hymn");
						if (hymns.size() > 0) {
							row.attr("id", serviceId+i);
							switch (hymns.size()) {
							case 1: {
								rowHtml =
										row(
												classTocVerse
												, row.id()
												, firstNWords(hymns.get(0).text( ),nGram) 
										);
								desigSb.append(rowHtml);
								index(firstNWords(hymns.get(0).text( ),nGram), file);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocVerse
												, row.id()
												, firstNWords(hymns.get(0).text( ),nGram) 
												, firstNWords(hymns.get(1).text(),nGram) 
										);
								desigSb.append(rowHtml);
								index(firstNWords(hymns.get(0).text( ),nGram), file);
								index(firstNWords(hymns.get(1).text( ),nGram), file);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(1).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml =
										row(
												classTocVerse
												, row.id()
												, firstNWords(hymns.get(0).text( ),nGram) 
													+ "  " + firstNWords(hymns.get(1).text( ),nGram)
												, firstNWords(hymns.get(2).text(),nGram) 
													+ "  " + firstNWords(hymns.get(3).text( ),nGram)
										);
								desigSb.append(rowHtml);
								index(firstNWords(hymns.get(0).text( ),nGram), file);
								index(firstNWords(hymns.get(1).text( ),nGram), file);
								index(firstNWords(hymns.get(2).text( ),nGram), file);
								index(firstNWords(hymns.get(3).text( ),nGram), file);

								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(1).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(2).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(hymns.get(3).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
						}
					}
					if (generateTocWithReadings) {
						Elements readings = row.getElementsByClass("reading");
						if (readings.size() > 0) {
							row.attr("id", serviceId+i);
							switch (readings.size()) {
							case 1: {
								rowHtml =
										row(
												classTocReading
												, row.id()
												, firstNWords(readings.get(0).text( ),nGram) 
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocReading
												, row.id()
												, firstNWords(readings.get(0).text( ),nGram) 
												, firstNWords(readings.get(1).text(),nGram) 
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(1).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
							case 3: {
								break;
							}
							case 4:
								rowHtml =
										row(
												classTocReading
												, row.id()
												, firstNWords(readings.get(0).text( ),nGram) 
													+ "  " + firstNWords(readings.get(1).text( ),nGram)
												, firstNWords(readings.get(2).text(),nGram) 
													+ "  " + firstNWords(readings.get(3).text( ),nGram)
										);
								desigSb.append(rowHtml);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(0).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(1).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(2).text( )
														,nGram)
														,row.id()
										)
								);
								theIndex.add(
										new IndexEntry(
												firstNWords(readings.get(3).text( )
														,nGram)
														,row.id()
										)
								);
								break;
							}
						}
					}
					if (generateTocWithChapVerses) {
						Elements chaps = row.getElementsByClass("chapverse");
						if (chaps.size() > 0) {
							row.attr("id", serviceId+i);
							switch (chaps.size()) {
							case 1: {
								rowHtml =
										row(
												classTocChapVerse
												, row.id()
												, chaps.get(0).text( ) 
										);
								desigSb.append(rowHtml);
								break;
							}
							case 2: {
								rowHtml = 
										row(
												classTocChapVerse
												, row.id()
												, chaps.get(0).text( )
												, chaps.get(1).text()
										);
								desigSb.append(rowHtml);
								break;
							}
							}
						}
					}
				}
				desigSb.append("</table>");
			}
			
			
			// Grab the cleaned up content section of the doc
			Elements content = doc.getElementsByClass("content");

			// Wrap the content with the required HTML opening and closing
			// blocks
			sb.append(HtmlUtils.HTMLopen);
			sb.append(HtmlUtils.getHead(title, css));
			sb.append(HtmlUtils.BODYopen);
			if (generateToc) {
				sb.append(heading);
				sb.append(desigSb.toString());
			}
			sb.append(heading);
			sb.append(content.html());

			java.util.Collections.sort(theIndex, new IndexEntryComparator());
			sb.append("<table>");
			Iterator<IndexEntry> it = theIndex.iterator();
			while (it.hasNext()) {
				sb.append(it.next().getValue());
			}
			sb.append("</table>");
			sb.append(HtmlUtils.BODYclose);
			sb.append(HtmlUtils.HTMLclose);

			// Create a resource for the transformed HTML
			result = new Resource(sb.toString().getBytes(
					Charset.forName("UTF-8")), newFileName);

			
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
	
	private void index(String key, String value) {
		if (bookIndex.containsKey(key)) {
			bookIndex.put(key, bookIndex.get(key) + ", " + value);
		} else {
			bookIndex.put(key, value);
		}
	}
	private String anchor(String pClassName, String href, String text) {
		return
				"<p class=\""
				+ pClassName 
				+ "\">"
				+  "<a class=\"" 
				+ pClassName 
				+ "\" href=\"#" 
				+ href 
				+ "\">"
				+ text 
				+ "</a>"
				+ "</p>";
	}
		
	private String tdLeft(String className, String href, String text) {
		return td("leftCell", className, href,text);
	}
	
	private String tdRight(String className, String href, String text) {
		return td("rightCell", className,href,text);
	}

	private String td(String tdClassName, String pClassName, String href, String text) {
		return
				 "<td class=\""
				+ tdClassName 
				+ "\">" 
				+ anchor(pClassName, href,text)
				+ "</td> "
				;
	}
	
	private String row(String cClassName, String href, String textLeft, String textRight) {
		return "<tr>"
				+ tdLeft(cClassName, href,textLeft)
				+ tdRight(cClassName,href,textRight)
				+ "</tr>";
	}
	
	private String row(String cClassName, String href, String text) {
		return "<tr>"
				+ tdLeft(cClassName,href,text)
				+ "</tr>";
	}
	
	private String firstNWords(String s, int nbrWords) {
		String result = "";
		StringBuffer sb = new StringBuffer();
		try {
			String [] parts = s.split(" ");
			int cnt;
			if (parts.length > nbrWords) {
				cnt = nbrWords;
				for (int i = 0; i < cnt; i++) {
					String word = parts[i];
					sb.append(word + " ");
				}
				result = sb.toString().trim();
				char last = result.charAt(result.length()-1);
				if (! Character.isLetter(last)) {
					if (last != ')') {
						result = result.substring(0, result.length()-1);
					}
				}
				result = result.replaceAll(" * ", " ");
				result = result + "...";
			} else {
				result = s;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
		
	private String serviceDateHeading(String day, String monthYear) {
		String result = day + ", " + monthYear;
		try {
			String theDayNbr = day.substring(0, 2);
			String theDayName = day.substring(3, day.length());
			result = theDayName + ", " + Integer.parseInt(theDayNbr) + " " + monthYear;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	private void writeEpubFile(Book book, String folder, String file) {
		try {
			GeneralUtils.createDir(folder);
			EpubWriter epubWriter = new EpubWriter();
			epubWriter.write(book, new FileOutputStream(folder+file));
			System.out.println(file);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Reads in the servicesindex.html file and initializes a map that records
	 * the titles of the month, service days, and the href to the index for each
	 * service day.
	 */
	private void loadServicesIndex() {
		serviceIndexDoc = getDoc(new File(pathToServicesIndex));
		Element servicesIndexTable = serviceIndexDoc.getElementsByClass(
				classServicesIndexTable).first();
		Elements rows = servicesIndexTable.getElementsByTag("tr");
		int monthCounter = 0;
		String monthKey = null;
		Iterator<Element> it = rows.iterator();
		while (it.hasNext()) {
			Element row = it.next();
			if (row.hasClass(classIndexMonthTr)) {
				String monthTitle = row.getElementsByClass(classIndexMonth)
						.first().text();
				monthCounter++;
				monthKey = padMonth(monthCounter);
				calendarMap.put(monthKey, new MonthCollection(monthTitle));
			} else if (row.hasClass(classIndexDayTr)) {
				Element link = row.getElementsByClass(classIndexDayLink)
						.first();
				String dayKey = link.text();
				String href = link.attr("href");
				MonthCollection m = calendarMap.get(monthKey);
				m.add(dayKey, pathToRoot + href);
				calendarMap.put(monthKey, m);
			}
		}
	}

	public void printCalendar() {
		Iterator<Entry<String, MonthCollection>> it = calendarMap.entrySet()
				.iterator();
		while (it.hasNext()) {
			Entry<String, MonthCollection> e = it.next();
			e.getValue().print();
		}
	}

	private String pad(int i, String prefix) {
		return prefix + String.format("%05d", i);
	}

	private String padMonth(int i) {
		return pad(i, "m");
	}

	private Document getDoc(File file) {
		Document result = null;
		try {
			result = Jsoup.parse(file, "UTF-8");
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	private Book initializeEpubBook(String theTitle, String theAuthor, String theDate) {
		
		Book book = null;
		try {
			// Create new Book
			book = new Book();

			// Set the title
			book.getMetadata().addTitle(theTitle);

			// Add an Author
			book.getMetadata().addAuthor(new Author(theAuthor));

			// Set cover image
//			book.setCoverImage(getResource(pathInResources + "cover.png",
	//				"cover.png"));

			// Set cover page
//			book.setCoverPage(getResource(pathInResources + "cover.html",
	//				"cover.html"));

			// Add the fonts
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font1),
							fontsPath + font1));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font2),
							fontsPath + font2));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font3),
							fontsPath + font3));
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + font4),
							fontsPath + font4));

			// Add css file
			book.getResources().add(
					new Resource(EpubBuilder.class
							.getResourceAsStream(pathInResources + css),
							stylesPath + css));

			// Add preface
			book.addSection(
					"Preface",
					getResource(EpubBuilder.class
							.getResourceAsStream(pathInResources
									+ "preface.html"), "preface.html"));

		// Add sources
			book.addSection(
					"Sources",
					getResource(EpubBuilder.class
							.getResourceAsStream(pathInResources
									+ "sources.html"), "sources.html"));
		} catch (Exception e) {
			e.printStackTrace();
		}
		return book;
	}

	private static InputStream getResource(String path) {
		return EpubBuilder.class.getResourceAsStream(path);
	}

	private Resource getResource(String path, String href) {
		try {
			return new Resource(getResource(path), href);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	private static Resource getResource(InputStream is, String href) {
		try {
			return new Resource(is, href);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
